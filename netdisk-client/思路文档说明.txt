【开发思路】
	方案一：业务系统直接调用接口上传文件
		优点：简单
		缺点：
			①无法控制切块大小，如果切块太大浪费网络传输资源；不同业务系统的切块标准不一样
			②如果不是前端上传，而是把服务器的文件同步到网盘，那么业务系统的实现难度比较大
		解决：sdk获取byte[],然后尝试再客户端进行重新切分，但是难度太大！！！！！！
		
	方案二：业务系统只需要把文件上传服务器本地，然后通知sdk去执行【使用该方案】
		优点：可以统一标准；业务系统灵活的比较高，只需要上传到本地文件即可
		缺点：
			①如果md5太大，则无法实时计算文件md5；
			②如果业务系统集群部署，并且是大文件切块上传，那么切块可能散落在不同服务器，无法合成一个完整的文件
			
		解决：业务系统的集群负载策略，使用ip_hash

一、心跳检查
	定时任务心跳检查服务器是否存活，实时更新activeHosts，避免无效请求
	【参考FileFactory.java】

二、文件上传
	1、先判断文件大小
		1.1、如果小于1g
			1.1.1、计算md5，并且和业务系统传递的md5做比较
			1.1.2、如果一致，则发起请求判断md5是否存在，如果已经存在则跳过，否则再往下执行
			
		1.2、如果大于1g，则跑定时任务去校验【请看下面】
			1.2.1、单点开启一个线程去计算md5
			1.2.2、主线程继续往下处理业务
			1.2.3、计算得到的md5再和业务系统传递的md5值做比较；如果一致则ok；如果不一致则标准有损坏*****************
			
	2、获取文件的总大小
	3、计算总切块数
	4、计算每个切块的起始下标，获取切块byte[]，然后上传服务端
	5、删除临时文件
	
	解决以下问题
		①容易内存溢出；【测试10线程同时上传15g的文件不会耗尽cpu和内存】
		②容易上传超时；【如果每次都计算md5，则大文件容易超时】
		③消耗服务器资源，影响客户端的性能【整个过程在业务系统端完成，耗的是业务系统服务端的资源，尽量降级消耗】

三、【未实现】接口安全性
	2.1、如果失败，则重试3次，3次还是失败，则更新activeHosts
	2.2、接口幂等性
	
四、【未实现】TCP模式
	
五、【未实现】难点
	FileServiceImpl.uploadLocalFile方法，开启线程池去上传切块的时候，如果其中一个切块上传失败，则如何停止跟其相关的所有线程呢？？
	避免继续上传，浪费资源
	
六、【未实现】Http接口切块大小控制
	netdisk-client-provider的http接口控制大小，比如业务系统是c#写的，无法使用javasdk，那么只能走http协议
	
	
	